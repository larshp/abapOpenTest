class ZCL_AOT_RUNNER definition
  public
  create public .

public section.

  methods CONSTRUCTOR
    importing
      !IO_PROJECT type ref to ZCL_AOT_PROJECT .
  methods RUN .
protected section.
private section.

  data MO_PROJECT type ref to ZCL_AOT_PROJECT .
  data MO_RUN type ref to ZCL_AOT_RUN .

  methods ANALYZE_RESULT
    importing
      !IS_TADIR type TADIR
      !IO_RESULT type ref to CL_SAUNIT_INTERNAL_RESULT
    returning
      value(RT_TESTS) type ZAOT_TESTS_TT .
  methods FIND_OBJECTS
    returning
      value(RT_TADIR) type TT_TADIR .
  methods FIND_PACKAGES
    returning
      value(RT_PACKAGES) type GAKH_T_TDEVC .
  methods GET_RUNNER
    importing
      !IV_COVERAGE type ABAP_BOOL default ABAP_FALSE
    returning
      value(RO_RUNNER) type ref to CL_AUCV_TEST_RUNNER_ABSTRACT .
  methods HAS_TESTS
    importing
      !IS_TADIR type TADIR
    returning
      value(RV_HAS_TESTS) type ABAP_BOOL .
  methods RUN_COVERAGE
    importing
      !IS_TADIR type TADIR .
  methods RUN_NORMAL
    importing
      !IS_TADIR type TADIR
    returning
      value(RT_TESTS) type ZAOT_TESTS_TT .
ENDCLASS.



CLASS ZCL_AOT_RUNNER IMPLEMENTATION.


  METHOD analyze_result.

    LOOP AT io_result->f_task_data-programs INTO DATA(ls_program).
      DATA(lv_program_index) = sy-tabix.
      LOOP AT ls_program-classes INTO DATA(ls_class).
        DATA(lv_class_index) = sy-tabix.
        LOOP AT ls_class-methods INTO DATA(ls_method).
          DATA(lv_method_index) = sy-tabix.

          READ TABLE io_result->f_task_data-alerts_by_indicies WITH KEY
            program_ndx = lv_program_index
            class_ndx = lv_class_index
            method_ndx = lv_method_index
            INTO DATA(ls_alert).
          IF sy-subrc = 0.
            DATA(lv_kind) = ls_alert-alerts[ 1 ]-kind.
          ELSE.
            CLEAR lv_kind.
          ENDIF.

          mo_run->append_test(
            VALUE #(
              program_name = ls_program-info-name
              class_name   = ls_class-info-name
              method_name  = ls_method-info-name
              kind         = lv_kind
              object_name  = is_tadir-obj_name
              object_type  = is_tadir-object ) ).

        ENDLOOP.
      ENDLOOP.
    ENDLOOP.

  ENDMETHOD.


  METHOD constructor.

    mo_project = io_project.

    mo_run = zcl_aot_run=>create( io_project ).

  ENDMETHOD.


  METHOD find_objects.

    DATA(lt_packages) = find_packages( ).

    LOOP AT lt_packages INTO DATA(ls_package).
      SELECT * FROM tadir
        APPENDING TABLE @rt_tadir
        WHERE object = 'CLAS'
        AND devclass = @ls_package-devclass.
    ENDLOOP.

  ENDMETHOD.


  METHOD find_packages.

    DATA(lv_package) = mo_project->get_details( )-devclass.

    SELECT * FROM tdevc APPENDING TABLE rt_packages WHERE devclass = lv_package.

    LOOP AT rt_packages INTO DATA(ls_package).
      SELECT * FROM tdevc APPENDING TABLE rt_packages WHERE parentcl = ls_package-devclass.
    ENDLOOP.

  ENDMETHOD.


  METHOD get_runner.

    DATA: lo_passport TYPE REF TO object.


    CALL METHOD ('\PROGRAM=SAPLSAUCV_GUI_RUNNER\CLASS=PASSPORT')=>get
      RECEIVING
        result = lo_passport.

    IF iv_coverage = abap_true.
      ro_runner = cl_aucv_test_runner_coverage=>create( lo_passport ).
    ELSE.
      ro_runner = cl_aucv_test_runner_standard=>create( lo_passport ).
    ENDIF.

  ENDMETHOD.


  METHOD has_tests.

    DATA(ls_aunit_info) = cl_aunit_prog_info=>get_program_info(
      allow_commit = abap_true
      obj_type     = is_tadir-object
      obj_name     = is_tadir-obj_name ).

    rv_has_tests = ls_aunit_info-has_tests.

  ENDMETHOD.


  METHOD run.

    DATA(lt_tadir) = find_objects( ).

    LOOP AT lt_tadir INTO DATA(ls_tadir).

      cl_progress_indicator=>progress_indicate(
        i_text               = |Processing { sy-tabix }/{ lines( lt_tadir ) } { ls_tadir-obj_name }|
        i_processed          = sy-tabix
        i_total              = lines( lt_tadir )
        i_output_immediately = abap_true ).

      IF has_tests( ls_tadir ) = abap_false.
* todo? also save coverage for non covered objects? or just assume uncovered?
        CONTINUE.
      ENDIF.

      run_normal( ls_tadir ).

      run_coverage( ls_tadir ).

    ENDLOOP.

  ENDMETHOD.


  METHOD run_coverage.

* todo

*      get_runner( )->run_for_program_keys(
*        EXPORTING
*          i_limit_on_duration_category = mo_project->get_details( )-duration
*          i_limit_on_risk_level        = mo_project->get_details( )-risk_level
*          i_program_keys               = VALUE #( ( CORRESPONDING #( ls_tadir ) ) )
*        IMPORTING
*          e_coverage_result            = DATA(li_coverage)
*          e_aunit_result               = DATA(li_aunit) ).

  ENDMETHOD.


  METHOD run_normal.

    DATA: lo_casted TYPE REF TO cl_saunit_internal_result.

    DATA(lo_timer) = NEW zcl_aot_timer( ).
    lo_timer->start( ).

    get_runner( )->run_for_program_keys(
      EXPORTING
        i_limit_on_duration_category = mo_project->get_details( )-duration
        i_limit_on_risk_level        = mo_project->get_details( )-risk_level
        i_program_keys               = VALUE #( ( CORRESPONDING #( is_tadir MAPPING obj_type = object ) ) )
      IMPORTING
        e_aunit_result               = DATA(li_aunit) ).

    DATA(lv_milli) = lo_timer->stop( ).

    lo_casted ?= li_aunit.

    mo_run->append_object( VALUE #(
      object_name = is_tadir-obj_name
      object_type = is_tadir-object
      runtime     = lv_milli ) ).

    rt_tests = analyze_result( is_tadir  = is_tadir
                               io_result = lo_casted ).

  ENDMETHOD.
ENDCLASS.
