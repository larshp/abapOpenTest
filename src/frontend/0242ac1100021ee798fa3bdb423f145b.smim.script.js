const base = '/sap/zabapopentest';

function handleError(evt, callback, json) {
  if (evt.target.status === 200) {
    if (json === true) {
      callback(JSON.parse(evt.target.responseText).DATA);
    } else {
      callback(evt.target.responseText);
    }
  } else {
    alert("REST call failed, status: " + evt.target.status);
  }
}

class REST {
  static root = base + "/rest/";

  static list(pkg, callback) {
    if (pkg==="") {
      callback([]);
    } else {
      this.get("list?IV_PACKAGE=" + pkg, callback);
    }
  }

  static run(cla, callback) {
    this.post("run", callback, cla);
  }

  static get(folder, callback, json = true) {
    let oReq = new XMLHttpRequest();
    oReq.addEventListener("load", (evt) => { handleError(evt, callback, json); });
    oReq.open("GET", this.root + folder);
    oReq.send();
  }

  static post(folder, callback, data) {
    let oReq = new XMLHttpRequest();
    oReq.addEventListener("load", (evt) => { handleError(evt, callback, true); });
    oReq.open("POST", this.root + folder);
    oReq.send(JSON.stringify(data));
  }
}

class SettingsComponent extends React.Component {
  constructor(props) {
    super(props);
  }

  handleChange(e) {
    this.props.settings.package = e.target.value;      
    this.props.updateSettings(this.props.settings);
  }

  render() {
    return (<div>
      Package: <input name="package" type="text" maxlength="30" value={ 
      this.props.settings.package } onChange={
      this.handleChange.bind(this)} />
    </div>);
  }
}

class RowComponent extends React.Component {
// row, results, columns

  findResult(column) {
    let result = undefined;

// todo, performance!
    for(let i=0; i<this.props.results.length;i++) {
      if(this.props.results[i].column === column) {
        for(let j=0; j<this.props.results[i].TESTS.length;j++) {
          if(this.props.results[i].TESTS[j].CLASS === this.props.row.CLASS 
              && this.props.results[i].TESTS[j].METHOD === this.props.row.METHOD) {
            result = this.props.results[i].TESTS[j].KIND;
          }
        }
      }
    }

    if(result === "") {
      return (<td style={{backgroundColor: "green"}}>{result}</td>);
    } else if (result === undefined) {
      return (<td>?</td>);
    } else {
      return (<td style={{backgroundColor: "red"}}>{result}</td>);
    }
  }

  render() {
    return (<tr>
      <td>{this.props.cla}</td>
      <td>{this.props.row.CLASS}</td>
      <td>{this.props.row.METHOD}</td>
      {this.props.columns.map((c) => {return this.findResult(c);})}
      </tr>);
  }
}

// todo, this class is a mess
class ResultsComponent extends React.Component {

  constructor(props) {
    super(props);
    this.changed = 0;
    this.queue = [];
    this.state = { 
      list: [], 
      results: {},
      columns: [] };
  }

  componentWillReceiveProps(nextProps) {
    this.state.columns = [];
    this.state.list = [];
    this.state.results = {};
    this.setState(this.state);

    this.changed = 0;
    this.queue = [];
  }

  componentDidMount() {
    this.registerTimeout();
  }

  findMax(list) {
    let max = 0;
// todo, change this loop to some fancy fp
    for(let i = 0; i<list.length; i++) {
      if (list[i].LAST_CHANGED > max) {
        max = list[i].LAST_CHANGED;
      }
    }
    return max;
  }

  registerTimeout() {
    setTimeout(() => {REST.list(this.props.settings.package, this.receiveList.bind(this)); }, 1000);
  }

  receiveRun(res) {
//    console.log("receive run: " + res.CLASS);
    res.column = this.current;
    this.state.results[res.CLASS].push(res);
    this.setState(this.state);
    this.processQueue();
  }

  processQueue() {
    var cla = this.queue.pop();
    if (cla) {
      REST.run(cla, this.receiveRun.bind(this));
    } else {
      this.registerTimeout();
    }
  }

  newRun(list) {
    this.current = new Date().toISOString();
    this.state.columns.push(this.current);
    this.queue = [];
    list.forEach((e) => { 
      if(!this.state.results[e.NAME]) {
        this.state.results[e.NAME] = [];
      }
      this.queue.push(e.NAME); });
    this.queue.reverse();
    this.processQueue();
  }

  receiveList(list) {
    this.state.list = list;

    let max = this.findMax(list);
    if (max > this.changed) {
      this.changed = max;
      this.newRun(list);
      this.setState(this.state);
    } else {
// look for changed classes
      this.registerTimeout();
    }
  }

  findRows(results) {
    let rows = [];

    results.forEach((e)=>(e.TESTS.forEach((t)=>{
// filter duplicates
      for (let i=0; i<rows.length; i++) {
        if(rows[i].CLASS === t.CLASS
            && rows[i].METHOD === t.METHOD) {
          return;
        }
      }

      rows.push({CLASS: t.CLASS, METHOD: t.METHOD})})));

    return rows;
  }

  map2(cla, r) {
    return (<RowComponent 
      cla={cla}
      row={r} 
      results={this.state.results[cla]}
      columns={this.state.columns} />);
  }

  map1(e) {
    let rows = this.findRows(this.state.results[e.NAME]);
    return rows.map((r) => { return this.map2.bind(this)(e.NAME, r); });
  }

  render() {
    return (<div>
      <br />
      <table>
      <ResultsHeaderComponent columns={this.state.columns} />
      {this.state.list.map(this.map1.bind(this))}
      </table>
      </div>);
  }
}

class ResultsHeaderComponent extends React.Component {

  column(e) {
    return (<td><u>{e.slice(11, 19)}</u></td>);
  }

  render() {
    return (<tr>
      <td><u>Class</u></td>
      <td><u>Test Class</u></td>
      <td><u>Method</u></td>
      {this.props.columns.map(this.column) }
      </tr>);
  }
}

class Application extends React.Component {
  constructor(props) {
    super(props);
    this.state = { 
      settings: { 
        package: ""
      },
      results: []};
  }

  updateSettings(s) {
    this.state.settings = s;
    this.setState(this.state);
  }

  render() {     
    return (<div>
      <SettingsComponent settings={this.state.settings} updateSettings={this.updateSettings.bind(this)}/>
      <ResultsComponent settings={this.state.settings} />
      <br />
      <a href={base + "/rest/swagger.html"}>swagger</a>
      </div>);
  }
}

ReactDOM.render(<Application />, document.getElementById('app'));
